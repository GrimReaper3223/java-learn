--------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------Inicio-------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------

VISAO GERAL MAIS APROFUNDADA SOBRE CLASSES E OBJETOS JAVA


CLASSES:

Resumo sobre Classes:

	ex. de declaracao de classe: public class App {};
	ex. de declaracao de classe que herda componentes de outra classe: public class App extends AppInterface {};
	ex. de declaracao de classe que herda uma classe e implementa uma interface: public class App extends AppInterface implements GeneralLogics{};
	
	O escopo de uma classe contem alguns elementos que tornam um arquivo uma classe:
		- Presenca ou ausencia modificadores de acesso (ex.: public, private, etc). Classes so podem ser privadas se forem aninhadas;
		- O nome da classe, com a inicial maiuscula por convencao;
		- Se houver uma superclasse, chama-la apos a palavra chave 'extends'. Uma classe so pode conter uma superclasse;
		- Se houver uma interface, chama-la apos a palavra chave 'implements'. Caso haja mais de uma interface, separar cada uma por
		  virgula. Uma classe pode implementar mais de uma interface;
		- O corpo da classe, entre colchetes {}. No corpo da classe pode conter campos, metodos e construtores de classe;
		
		
Resumo sobre variaveis de membro;

	Como ja visto anteriormente, existem varios tipos de variaveis:
		- Variaveis de membro em uma classe --- sao chamadas de campos;
		- Variaveis em um metodo ou bloco de codigo --- sao chamadas de variaveis locais;
		- Variaveis em declaracoes de metodos --- sao chamadas de parametros;
		
	E a declaracao de um campo contem os 3 seguintes elementos:
		- Zero ou mais modificadores de acesso, como public ou private por exemplo;
		- O tipo do campo;
		- O nome do campo;
		
	Os campos public e private controlam quem tem acesso a esses tipos de dados.
	
	
Resumo sobre controle de acessso a um membro:
	
	O primeiro modificador mais a esquerda usado permite controlar quais outras classes tem acesso a um campo de membro.
	Existem varios modificadores. No entanto, os mais comumente utilizados sao public e private.
	
		public - pode ser acessado por qualquer lugar do projeto;
		private - pode ser acessado apenas na classe em que e declarado;
		
	Um programa robusto, seguro e modular faz uso constante de encapsulamento. A palavra chave private torna o encapsulamento possivel, visto
	que os dados de um membro so podem ser alterados por metodos, e nao por qualquer lugar do projeto ou por meios externos.
	Para obter e definir valores a esses membros privados, precisamos de metodos dentro da classe onde estao os membros privados que realizem essa funcao.
	Esses metodos sao chamados de getters e setters (ou get e set para melhor entendimento). 
	
	Quando precisamos obter um valor de uma variavel privada, utilizamos o metodo 'get' para retornar o valor de tal variavel.
	Quando precisamos atribuir um valor a uma variavel privada, utilizamos o metodo 'set' para definir o valor de tal variavel.
	
	Nao ha um metodo get e set para isso. Mas, para facilitar no entendimento do programa de modo geral, utilizamos getNomeDaVariavel() para
	se obter um valor, e setNomeDaVariavel() para definir um valor.
	Metodos que obtem valores de variaveis privadas (get) nao contem parametros e retornam o valor da variavel, que deve ser o mesmo tipo de retorno do metodo.
	Metodos que definem valores (set) nao retornam nada e contem um parametro (basicamente), e o argumento passado a esse parametro sera atribuido a variavel
	privada de tipo correspondente.
	
	ex.:
		//variaveis privadas
		private int number;
		private String str;
		
		//metodos get e set para number
		public int getNumber() {
		     return number;
		};
		
		public void setNumber(int value) {
		     number = value;
		}
		
		//metodos get e set para str
		public String getString() {
		     return str;
		};
		
		public void setString(String stringValue) {
		     str = stringValue;
		};
		
	NOTA: Nao e obrigatorio o uso da nomenclatura get e set antes do nome do metodo que obtem ou define algo. Mas e recomendavel, 
	      por boas praticas de programacao, para que seja mais facil a legibilidade de um metodo.
	      Seria muito mais facil ler getNumber, e entender que aquele metodo obtem um numero, do que numberStorage, que da a entender que 
	      aquele metodo ira armazenar um numero ou que um numero pode ser armazenado nele ou que ele chama outro metodo que armazena numeros...
	      Sao muitas ambiguidades.
	

Explicacao sobre configuracao de tipos de uma variavel:

	todas as variaveis devem ter um tipo. Podemos utilizar um tipo primitivo de dados (int, float, double...), ou tipos de referencia
	(String, arrays ou algum objeto instanciado).

Nota: As regras de convencao citadas nos fundamentos da linguagem ainda prevalecem.


METODOS

Resumo sobre definicao de metodos:

	De forma resumida para que um metodo funcione, os unicos elementos necessarios em uma declaracao de metodo sao o tipo de retorno do 
	metodo, o nome, um par de parenteses e o corpo do metodo entre colchetes {}.
	
	De forma mais completa e geral, as declaracoes de metodo contem seis componentes, em ordem:
	
	1 - Zero ou mais modificadores, como public, private... dentre outros que sera discutido mais tarde;
	2 - O tipo de retorno - o tipo de dados do valor retornado pelo metodo ou void se nao retornar nada;
	3 - O nome do metodo - as regras de convencao de nomenclaturas para metodos sao as mesmas de nomes de campos, mas com algumas diferencas;
	4 - Uma lista de parametros entre os parenteses - Cada parametro deve ser delimitado por virgula, precedido pelo seu tipo e nome.
	    Se nao houver parametros, os parenteses devem ficar vazios;
	5 - Uma lista de excessoes - que sera discutido mais tarde; 
	6 - O bloco de execucao de instrucoes do metodo - aqui vao declaracoes de variavels locais e o codigo do metodo;
	
	Modificadores, tipos de retorno e parametros serao posteriormente discutidos. Excessoes serao discutidas em outra secao.
	
	DEFINICAO: somente 2 dos componentes de um metodo compreendem sua assinatura. Sao eles: Nome do metodo e seus parametros. ex.:
		   processData(String, String, int, int) ou processData();
		   Podemos chamar metodos declarados na classe em outras partes da classe usando sua assinatura. Tambem podemos chamar 
		   um metodo por sua assinatura a partir da instancia de uma classe, usando a referencia da instancia (objeto) com notacao de ponto
		   e a assinatura do metodo.
		   A assinatura de um metodo ou construtor e uma parte fundamental da composicao de um projeto Java.


Resumo sobre Nomeacao de metodos:

	A convencao define que nomes de metodos devem ser os mesmos de um campo, mas com algumas mudancas. Os nomes dos metodos devem ser um
	verbo, em letras minusculas, ou um nome com varias palavras que comece com um verbo minusculo, seguido por adjetivos, substantivos, etc.
	Em nomeacoes com varias palavras, a primeira letra de cada palavra subsequente deve ser capitalizada (ou maiuscula). Aqui estao alguns
	exemplos:
	
		run;
		runFast;
		getBackground;
		getFinalData;
		compareTo;
		setX;
		isEmpty;
	
	Normalmente, um metodo possui um nome exclusivo dentro de uma classe. No entanto, metodos podem ter o mesmo nome, mas com os parametros
	da assinatura diferentes. Isso e chamado sobrecarga de metodos.
	
	
Resumo sobre sobrecarga de metodos
	
	Java suporta metodos sobrecarregados, e o compilador consegue distinguir metodos com nomes iguais, mas com parametros diferentes.
	Ou seja, se a assinatura de um metodo conter uma quantidade e tipos diferentes de parametros, mas com nomes iguais, a sobrecarga de metodos
	e empregada. 
	As qualificacoes para se utilizar esse tipo de codificacao serao discutidas na secao 'heranca'.
	
	*NOTA: A assinatura de um metodo foi visto acima em 'DEFINICAO';
	
	Existe um porque para se utilizar sobrecarga de metodos em situacoes especificas. Uma delas e que voce nao precisa criar um novo nome 
	para cada metodo que realiza a mesma funcao. Por exemplo, se tivermos uma classe que e focada no desenho da interface do usuario, podemos
	utilizar um metodo draw. Mas, ao inves de criarmos diversos metodos draw (drawMenu, drawText, drawNewScreen), podemos fazer
	uso da sobrecarga de metodos, criando varios metodos draw, mas com parametros diferentes. ex.:
		
		draw(Object button, Object inputFields) {};
		draw(String text) {};
		draw(Object screen, Object button, Object inputFields) {};
	
	Os metodos sobrecarregados sao diferenciados pelo numero e tipo de parametros. Poderiamos ter varios metodos draw() com 1 parametro
	somente em cada um. Mas cada parametro de cada metodo draw() deveria ser de tipo diferente.
	
	O compilador nao pode executar, no caso de metodos de sobrecarga, metodos que disponham de assinaturas identicas, porque nao ha uma 
	diferenciacao de um metodo para outro.
	
	O compilador nao considera o tipo de dados que um metodo retorna para sobrecarregar metodos, porque o retorno de dados nao faz parte
	da assinatura de um metodo. Portanto, nao podemos declarar 2 metodos estritamente iguais, mas com retornos diferentes.
	
	Em resumo: metodos sobrecarregados utilizam-se da assinatura de um metodo como verificacao pelo compilador, independente de seu tipo 
	de retorno ou codigo dentro do corpo do metodo.
	
NOTA: Metodos sobrecarregados devem ser usados com moderacao e em situacoes especificas, como tambem acontece com rotulos. Do contrario, o codigo
      pode se tornar menos legivel e dificultar significativamente a manutencao. Caso necessite fazer o uso de tais praticas, documente 
      detalhadamente o funcionamento de cada classe e metodos em javadocs e comentarios.
      
      
      
CONSTRUTORES DE CLASSES

Resumo sobre construtores de classe:
	
	Uma classe pode conter ou nao construtores que sao invocados para criar objetos a partir do blueprint (escopo) da classe.
	O objeto, entao, passa a ser um pacote, container ou algo do tipo que armazena toda a classe e suas definicoes, fazendo com que o 
	uso de metodos da classe se torne simplificado, apenas utilizando aquele objeto instanciado.
	
	Os construtores podem ser analogamente comparados a uma fabrica. Seguindo a analogia no campo teorico, os construtores sao fabricas de objetos.
	E como sabemos, uma fabrica nao cria apenas um produto, podendo criar varios produtos diferentes do mesmo tipo. O mesmo funcionamento tambem
	pode ser aplicado aos nossos construtores.
	
	As declaracoes de construtores se assemelham com declaracoes de metodos - exceto pelo fato de usarem o nome da classe e nao terem um tipo
	de retorno.
	
	O construtor da classe Bicycle (classe que esta sendo usada desde nossa primeira aula) pode receber ou nao parametros. 
	ex.:
		public Bicycle(int startCadence, int startSpeed, int startGear) {
		     gear = startGear;
		     cadence = startCadence;
		     speed = startSpeed;		     		     
		};
		
	O construtor da classe que recebe parametros e os atribui a variaveis de classe tem seu funcionamento similar ao metodo set, porem, 
	sem a nomenclatura 'set' antes do nome do construtor e sem um retorno.
	Para criarmos um novo objeto do projeto Bicycle chamado myBicycle, podemos, em outra classe, chamar o construtor desta classe com o 
	operador new (operador que cria instancias de classes). ex.:
	
		Bicycle myBicycle = new Bicycle(30, 0, 8);
		
	O codigo acima 'new Bicycle(30, 0, 8)' cria espaco na memoria para o objeto myBicycle e inicializa todos os campos referente a classe 
	que o objeto esta instanciando com os valores passados aos parametros do construtor da classe. 
	Entao, os campos gear, cadence e speed do novo objeto instanciado myBicycle, recebem, respectivamente, os valores 30, 0 e 8.
	Percebe-se que Bicycle(30, 0, 8) se assemelha muito a assinatura de um metodo. Podemos, entao, dizer que um construtor tem tambem uma assinatura.
	
	Poderiamos tambem criar mais de um construtor dentro de nossa classe Bicycle. Poderiamos ate mesmo, criar um construtor secundario sem 
	argumentos
		public Bicycle() {
		    gear = 1;
		    cadence = 10;
		    speed = 0;
		};
	
	Se convertermos o codigo Bicycle myBicycle = new Bicycle(30, 0, 8); para Bicycle myBicycle = new Bicycle();, teremos uma instancia de
	Bicycle	sem argumentos. Poderiamos tambem ter mais de um objeto Bicycle, com ou sem argumentos, instanciados com valores diferentes 
	usando o mesmo construtor ou mais de um, somente mudando o nome da instancia, como, por exemplo:
	
		Bicycle myBicycle1 = new Bicycle(30, 0, 8); 	//construtor bicycle com parametros
		Bicycle myBicycle2 = new Bicycle(15, 3, 10);	//construtor bicycle com parametros
		Bicycle myBicycle3 = new Bicycle();		//construtor bicycle sem parametros
		Bicycle myBicycle4 = new Bicycle(22, 0, 15);	//construtor bicycle com parametros
		Bicycle myBicycle5 = new Bicycle();		//construtor bicycle sem parametros
		
	Ambos os construtores podem ter o mesmo nome. Podem existir mais construtores de classe com o mesmo nome da classe, porque a plataforma 
	Java, assim como acontece com os metodos de sobrecarga, consegue diferenciar os construtores com base no numero de argumentos na lista 
	de parametros e em seus tipos (como se os construtores tivessem tambem uma assinatura, como ja dito anteriormente).
	Nao pode haver 2 construtores com "assinaturas" iguais (com excessao do nome, com quantidade e tipo de parametros identicos), pois 
	o compilador nao conseguiria diferenciar entre eles e isso resultaria em erro de tempo de compilacao (RuntimeException).
	
	Em resumo, da mesma forma que existem metodos de sobrecarga, existem tambem, logicamente, "construtores sobrecarregados".
	
	E possivel nao atribuir nenhum construtor a sua classe, mas deve-se ter cuidado ao tomar essa decisao. 
	Como Java e uma linguagem orientada a objetos e voce nao declare um construtor (mesmo que sem argumentos) em sua classe e voce precise
	instanciar um objeto dela, o compilador	fornece um construtor padrao e sem argumentos para sua classe para que, entao, possa ser criado 
	um objeto que represente sua classe. Se a classe nao faz uso de heranca explicita, ou seja, uma superclasse declarada explicitamente 
	na classe, a classe tera uma superclasse implicita de Object, que possui um construtor sem argumentos.
	
	Se for identificado o uso de heranca em sua classe, o compilador, alem de chamar um construtor padrao para sua classe, ele verificara
	se sua superclasse tem um construtor padronizado, ou seja, sem argumentos. Se nao houver, o compilador ira reclamar sobre isso.
	
	Podemos, tambem, utilizar um construtor da superclasse em nossa classe filha. Como foi o caso do exemplo no inicio dos estudos dessa 
	nova sessao no site dev.java, utilizando a classe MountainBike, que fez exatamente isso. Recaptulacao do exemplo abaixo:
		
		SUPERCLASSE BICYCLE:
			
			public class Bicycle {
		
	    			// the Bicycle class has
				// three fields
				public int cadence;
	    			public int gear;
	    			public int speed;
		
				// the Bicycle class has
				// one constructor
				public Bicycle(int startCadence, int startSpeed, int startGear) {
					gear = startGear;
					cadence = startCadence;
					speed = startSpeed;
				};
				
				//aqui vao metodos de manipulacao de membros da classe
		  	};
		  	
		SUBCLASSE MOUTAINBIKE
		
			public class MountainBike extends Bicycle {
        
			    // the MountainBike subclass has
			    // one field
			    public int seatHeight;

			    // the MountainBike subclass has
			    // one constructor
			    public MountainBike(int startHeight, int startCadence,
						int startSpeed, int startGear) {
				super(startCadence, startSpeed, startGear);
				seatHeight = startHeight;
			    };   
			    
			    //aqui vao metodos de manipulacao de novos membros da subclasse
			};

***	
Entendendo melhor como foi utilizado o construtor no exemplo acima:

	Como visto, MountainBike (subclasse) herda de Bicycle (superclasse) todos os seus componentes.
	Mesmo que a subclasse herde tambem o construtor da superclasse, ela deve ter tambem um construtor.
	O construtor da subclasse sera focado em implementar novas funcionalidades, mas tambem deve realizar a chamada do construtor da superclasse e a ele fornecer os devidos argumentos de inicializacao.
	No construtor da superclasse, temos 3 parametros do tipo inteiro, enquanto na subclasse, temos 4 parametros do tipo inteiro. 
	O primeiro parametro da subclasse claramente aponta para uma implementacao, enquanto os 3 restantes claramente apontam para os 3 parametros do construtor da superclasse.
	Nao e uma regra definirmos o mesmo nome dos parametros do construtor da superclasse nos parametros do construtor da subclasse, nem a ordem exata. Mas como uma boa pratica de programacao devemos 
	faze-lo, para que tudo fique mais organizado no nosso codigo.
		
	No bloco de codigo do construtor da subclasse, devemos realizar a chamada do construtor da superclasse com a palavra chave super, seguido dos parametros que voce deseja passar como argumento ao 
	construtor da superclasse.
	Como dito antes, nao e a toa que o construtor da subclasse tem o mesmo nome e tipo de parametro que o construtor da superclasse. No exemplo acima, passamos para a chamada do construtor da superclasse
	os parametros do construtor da subclasse com tipos, nomes e ordem iguais aos parametros do construtor da superclasse como argumento.
	A chamada do construtor da superclasse deve sempre estar declarada antes das implementacoes. Ou seja, deve ser a primeira linha de codigo que o construtor da subclasse ira executar.
	
	A execucao detalhada de como tudo funciona acontece da seguinte forma: 
		-O compilador executa o construtor da superclasse, passando como argumento os parametros do construtor da subclasse que foi atribuido na chamada do construtor da superclasse usando a 
		 palavra chave super. 
		-Ao executar o construtor da superclasse com os devidos valores, como essa execucao e por meio de heranca, entao um objeto da classe Bike nao sera criado, mas sim seus campos inicializados
		 e fornecidos ao construtor da subclasse. Ou seja, quem ira criar o objeto manipulavel sera a subclasse.
		-Entao, a execucao do codigo volta para a subclasse para terminar de inicializar as novas implementacoes e criar o objeto.
		
	Resumindo: quando o construtor da subclasse e chamado, o construtor da superclasse e chamado com os devidos valores como argumento. Ele inicializa seus campos e metodos e a subclasse estende (ou 
		   a superclasse entrega a subclasse, como quiser chamar) esses campos e metodos inicializados pela superclasse. Por fim, a execucao do programa volta ao construtor da subclasse para terminar
		   de performar sobre as novas implementacoes e assim criar um unico objeto com todos os componentes da superclasse e da subclasse.
***	

	Como se trata de heranca, entao isso sera discutido mais em breve...
	
	E, por fim, tambem podemos utilizar modificadores de acesso na declaracao de um construtor para controlar quais outras classes podem ter 
	acesso a ele.
	

CHAMADA DE METODOS E CONSTRUTORES

Resumo sobre passando informacoes para um metodo ou construtor:

	Na declaracao de um metodo ou construtor, podemos fazer uso de parametros. Esses parametros recebem argumentos, que sao passados em tempo de execucao 
	durante chamada de metodo ou construtor.
	Para exemplificar melhor, digamos que o usuario chamou uma funcao de atribuicao. Digamos que essa funcao seja para mudar alguma configuracao 
	pre estabelecida. O novo valor de configuracao que o usuario fornece ao programa sera um argumento. Assim que o usuario confirmar a mudanca,
	sera chamado o metodo que vai performar essa funcao, e ele recebera o argumento que o usuario inseriu em seu parametro. O metodo usara aquele argumento
	como base para alterar, por fim, a configuracao, de acordo com o que foi programado.
	
	Nota: parametros sao variaveis de declaracao de metodo e argumentos sao dados passados a esses parametros quando um metodo/construtor e invocado.
	      quando um metodo/construtor e invocado, os argumentos (se houverem) devem corresponder aos parametros da declaracao em tipo de dado e ordem

	      
Resumo sobre tipos de parametros:

	Pode-se ser usado qualquer tipo de parametro para metodos ou construtores. Desde tipos primitivos, ate tipos de referencia como Strings, Objects, Arrays, etc.
	Podemos ter um metodo que retorna um objeto usando outro como parametro. ex.:
	
	public Polygon polygonFrom(Point[] corners) {
    	// method body goes here
	}
	
	No exemplo acima, o metodo ira criar um novo objeto Polygon, e o inicializa a partir de um array de objetos do tipo Point (passado como argumento).
	Digamos que Point seja uma classe que contem coordenadas para desenho.
	Para entendermos de forma mas simplista o que foi dito acima, o metodo vai retornar um objeto do tipo Polygon, que sera desenhado dentro do metodo usando uma array de objetos do tipo Point.
	Essa array de objetos do tipo Point, pode conter varias coordenadas que, desenhadas, forma um poligono.
	No bloco de codigo, existirao metodos que vao desenhar um poligono usando as coordenadas de Point, ou iterar sobre cada elemento de Point, no caso, coordenadas x,y
	e adicionar (.add) ao objeto Polygon, fazendo com que o objeto Polygon contenha o desenho de um poligono.
	
	
Resumo sobre numeros arbitrarios de argumentos:
	
	sintaxe do parametro varArgs: public String searchValue (String... varargs) {// logicas do metodo};
				      public int calculation(int a, int b, int... varargs) {// logicas do metodo};
	
	Em java, quando nao sabemos quantos argumentos um metodo ira receber, usamos um tipo especial de parametro chamado varargs. Essa construcao permite que um usuario ou outra 
	parte do codigo forneca a esse metodo uma quantidade indefinida de argumentos do mesmo tipo.
	Podemos passar 1 matriz como argumento de varArgs ou dados individuais do mesmo tipo e separados por virgula.
	
	NOTA: O nome do parametro arbitratio nao precisa ser necessariamente varArgs. Aqui usamos varArgs para melhorar a explicacao.
	
	Enquanto criar arrays em parametros de metodos seja um pouco mais custoso (a array deve conter ou receber valores, esses valores passados ao metodo e o metodo performar
	a execucao desses valores), varArgs faz o mesmo trabalho, com a diferenca que pode receber tanto arrays, quanto uma lista de argumentos do mesmo tipo separados por virgula
	Inclusive, o compilador, na hora de executar aquele metodo, trata varArgs como um array. Ou seja, para o compilador nada muda, mas para o dev se torna bem mais simples.
	
	Cada metodo so pode ter 1 parametro varArgs, e esse parametro varArgs deve ser colocado como ultimo parametro.
	Caso o parametro varArgs seja colocado em qualquer posicao na lista de argumentos, um erro de compilacao sera lancado.
	
	Os parametros em varArgs, como dito antes, podem ser dinamicos (fornecidos pelo usuario em tempo de compilacao) ou nao (pre programados). 
	
	Como um exemplo de uso logico, podemos pedir ao usuario, ao menos, 3 parametros para realizar uma pesquisa num banco de dados.
	se o usuario inserir somente 2, podemos invalidar o terceiro parametro com um dado nulo para que ele nao interfira na pesquisa dos 2 parametros que o usuario passou.
	
	

Resumo sobre nome de parametros: 

	O nome de um parametro deve ser exclusivo no escopo da estrutura de um metodo ou construtor. Nao deve haver mais de um parametro com nomes iguais na declaracao 
	daquele metodo ou construtor. 
	O nome desse parametro e usado no corpo do metodo/construtor para se referir ao argumento (valor) passado a ele.
	Um parametro pode ter o mesmo nome que um dos membros de uma classe (campo). Caso isso aconteca, dizemos que o parametro sombreia o campo. Os parametros de sombreamento 
	dificultam a leitura do codigo e so sao usados convencionalmente em metodos ou construtores que definem valores aos campos da classe.
	
	ex.:	
		private int number;
		
		public void setNumber(int number) {
			this.number = number;		
		}
		
	no exemplo acima, temos uma variavel privada chamada number. Usamos um metodo para definir um valor para essa variavel privada. 
	Esse metodo contem um tipo de dado inteiro e o mesmo nome do campo da classe. no corpo do metodo, fazemos a atribuicao do argumento passado ao metodo ao campo da classe 
	utilizando a palavra chave 'this'.
	
	quando temos parametros que sombreiam campos e precisamos que o argumento passado a esse parametro sombreado seja atribuido ao campo da classe, usamos a palavra chave 'this'.
	'this', em traducao, significa 'esse'. Entao, no escopo do exemplo, podemos dizer que o metodo atribui o argumento passado a number a 'esse' number.
	
	a palavra chave 'this' faz referencia a campos fora do metodo. primeiro chamamos 'this'. Em seguida, com notacao de ponto, chamamos o nome do campo que queremos referenciar
	e daqui por diante podemos fazer algumas operacoes (seja ela de atribuicao, soma, multiplicacao, adicionar ou subtrair ao valor da variavel, etc).
	Mais sobre a palavra chave 'this' sera explicado mais a frente...
	
	
	
Resumo sobre argumentos passados como tipo de dados primitivos:

	Argumentos como int, double, char... de tipos primitivos, sao passados a metodos por valor. Isso significa que qualquer mudanca nos valores dos parametros existem apenas 
	dentro do escopo do metodo ou construtor. Assim que o metodo retorna, ou seja, deixa de ser executado, os argumentos passados ao parametro desaparecem, e qualquer nova chamada
	daquele metodo nao contara com valores antigos, sendo necessario inserir novos valores.
	


Resumo sobre passar argumentos por tipo de dados de referencia:

	Parametros do tipo de dados de referencia tambem recebem argumentos por valor. O que significa que quando o metodo retorna, a referencia passada ainda faz referencia ao 
	mesmo objeto de antes. Porem, os valores dos campos do objeto podem ser alterados no metodo, desde que tenham o nivel de acesso adequado para isso.
	
	por exemplo, vamos considerar um metodo em uma classe arbitraria que move objetos do tipo 'Circle':
	
	
	public void moveCircle(Circle circle, int deltaX, int deltaY) {
	    // code to move origin of circle to x+deltaX, y+deltaY
	    circle.setX(circle.getX() + deltaX);
	    circle.setY(circle.getY() + deltaY);
        
	    // code to assign a new reference to circle
	    circle = new Circle(0, 0);
	}
	
	vamos invocar o metodo com os seguintes dados:
	moveCircle(myCircle, 23, 56);
	
	
	dentro do metodo moveCircle, circle, inicialmente, se refere a myCircle. 
	O metodo altera as coordenadas x e y do objeto ao qual 'circle' faz referencia (ou seja, myCircle) em 23 e 56, respectivamente.
	Essas alteracoes persistirao no objeto assim que o metodo retornar.
	Em seguida, e atribuido a 'circle' uma referencia de um novo objeto 'Circle' com as coordenadas 0 para x e y. 
	Essa reatribuicao nao tem permanencia porque os valores foram passados como referencia e o metodo alterou os valores das variaveis do objeto.
	Entao, se o metodo deixar de ser executado, o objeto myCircle tera sido alterado, enquanto a reatribuicao ira morrer junto com a execucao do metodo.
	Na proxima chamada deste metodo, myCircle vai conter as alteracoes feitas anteriormente, enquanto o novo objeto Circle atribuido ao parametro pela ultima vez
	nao vai existir, apenas ao fim do codigo, onde ele sera criado e apagado junto com o metodo novamente.
	


CRIANDO E USANDO OBJETOS

Resumo sobre compreensao de objetos:

	Objetos em Java sao uma copia de toda a estrutura de uma classe empacotada em uma referencia a ela. Um aplicativo Java normalmente contem muitos desses objetos que formam uma interacao a partir 
	da invocacao de metodos.
	Atraves dessas interacoes de objetos, um programa pode desenhar uma GUI, processar informacoes, aguardar dados do usuario e processa-los, manipular um banco de dados, manipular redes, etc.
	Depois que o objeto conclui seu trabalho para o qual foi chamado, ele tem seus recursos reciclados (memoria, processamento, armazenamento...) para que outros objetos tambem possam utilizar desses 
	recursos, sem que isso se torne oneroso para o sistema.
	
	
Resumo sobre criacao de objetos:

	sintaxe da criacao de objetos: type name = new constructor();
				       type name = new constructor(param1, param2, ..., ...);

	Como sabemos, uma classe fornece o seu modelo para um objeto. Um objeto e uma copia completa de uma classe. Cada linha de codigo presente numa classe e fornecida a um objeto e esse objeto e atribuido
	a uma variavel equivalente ao tipo da classe que esta sendo instanciada.
	
	O site dev.java nos fornece alguns exemplos:
	
		Point originOne = new Point(23, 94);
		Rectangle rectOne = new Rectangle(originOne, 100, 200);
		Rectangle rectTwo = new Rectangle(50, 100);

***	Nem todos os exemplos foram copiados de la para nosso arquivo para que ele nao fique muito grande (muito grande mesmo). O recomendavel seria pesquisar na sessao correspondente ao que aqui esta
	documentado, afim de achar algum exemplo solido. 
	
	De acordo com nosso exemplo acima, a primeira linha cria um objeto do tipo Point, chamado originOne, e a segunda e terceira linha criam objetos do tipo Rectangle, chamadas de rectOne e rectTwo, 
	respectivamente. 
	Cada uma dessas linhas compartilham as mesmas partes que tornam a instanciacao de um objeto possivel. Sao elas:
	
		-Declaracao: Inicialmente, devemos declarar uma variavel, e seu tipo deve ser correspondente ao objeto a ser armazenado nela. Essa variavel ira armazenar a instancia de uma classe;
		-Instanciacao: A palavra-chave 'new' e um operador que cria uma nova instancia de uma classe;
		-Inicializacao: O unico argumento pos-fixado do operador 'new' (posterior ao operador 'new'), e a assinatura do construtor da classe a ser instanciada. E chamado, entao, o construtor da
				classe que corresponde,	de alguma forma, ao tipo de variavel que o objeto sera armazenado. Se ele tiver parametros, deve-se fornecer argumentos durante a inicializacao.
				Se nao, os parenteses devem ficar vazios;
	
	
	Declarando uma variavel para se referir a um objeto:
	
		Antes de iniciarmos esse resumo, a sintaxe da criacao de objetos foi abordada e faz alusao a uma compreensao geral sobre o processo basico da criacao de um objeto.
		Ja vimos anteriormente tambem como podemos declarar uma variavel. 
		Seja a variavel sendo um tipo primitivo ou por referencia, a declaracao de uma variavel faz com que o programa notifique ao compilador que a variavel declarada com tal nome recebera um 
		valor em algum momento do codigo, e que, para isso, o compilador reserve um espaco na memoria para ela.
		
		Podemos declarar uma variavel em uma linha, sem nenhum valor. Pode ser tanto uma variavel de tipo de referencia ou primitiva (exceto variaveis locais, onde precisa de um valor para ser
		inicializada).
		Podemos nao atribuir um valor a uma variavel de tipo primitivo, mas devemos fazer isso com uma variavel de tipo de referencia. Nos podemos declarar um espaco na memoria para aquela 
		variavel de tipo de referencia, mas em algum momento do codigo, devemos atribuir um valor a ela no codigo.
		Antes de iniciarmos nosso programa, tudo deve estar definido. Caso contrario, o compilador ira entender que ha espacos nunca inicializados na memoria e isso retornara um erro.		
		
		Um tipo de referencia declarado nao garante que um objeto seja criado. Isso so se torna possivel com o operador 'new'. Uma variavel de referencia neste estado nao faz referencia a objeto
		algum, pois a ela nao foi atribuida nenhuma instancia.
	
	
	Instanciando uma classe:
	
		O operador 'new' e responsavel por alocar espaco na memoria para criar um objeto chamando o construtor dele, e retornar a referencia a esse espaco a uma variavel do tipo apropriado ao 
		do objeto.
		
		NOTA: A frase "instanciar uma classe" significa a mesma coisa que "criar um objeto". Ao criar um objeto, estamos criando uma "instancia" daquela classe. Logo, estamos "instanciando" uma 
		      classe. Uma instancia pode ser compreendida como um segundo objeto do mesmo tipo do primeiro sendo executado na memoria. Como exemplo pratico, podemos citar as varias instancias do 
		      terminal linux que abrimos assim que ligamos o computador. Cada instancia utiliza os mesmos recursos do sistema (funcionamento identico a classes em Java) e cada uma dela pode
		      desempenhar uma tarefa diferente: uma para atualizar o sistema, outra para acessar arquivos, outra para abrir programas, etc.
		
		Como dito anteriormente, de forma mais geral, tudo o que existe numa classe e fornecido a um objeto, e esse objeto e atribuido a uma variavel de tipo equivalente ao da classe instanciada.
		Isso e feito com o operador 'new', que retorna a referencia na memoria do objeto criado daquela classe para uma variavel de tipo equivalente da classe que o objeto instancia.
		
		A referencia retornada pelo operador 'new' nao precisa necessariamente ser atribuida a uma variavel de tipo equivalente ao objeto. Podemos atribui-lo diretamente a uma expressao 
		(ou variavel de tipo primitivo). Vamos utilizar nosso exemplo anterior para ilustrar melhor o que foi dito:
		
			Point originOne = new Point(23, 94); // originOne e uma variavel de tipo equivalente (Point) a classe que sera instanciada (Point).
			
			Point originOne;		     // originOne e uma variavel do tipo Point, que aguarda uma atribuicao a ela de um objeto do tipo equivalente a ela (Point).
			originOne = new Point(23, 94);	     // Chamamos originOne para instanciarmos e inicializarmos um objeto e atribuir o processo a essa variavel, fazendo dela uma referencia da classe.
			
			int height = new Rectangle().getHeight();  //Aqui chamamos o metodo getHeight() para obter a altura do retangulo. Geralmente usamos metodos para obter valores quando um campo e
								   //privado. como o valor retorna um int, entao podemos armazena-lo na variavel 'height'.
								   
			int height = new Rectangle().Height;	   //Aqui obtemos o valor da variavel Height de retangulo de forma direta. Geralmente podemos fazer dessa forma quando um metodo nao e private.
								   //Como o valor retornado e um int, podemos armazena-lo na variavel height.
		
		Em ambos os casos do tipo 'int', assim que o objeto e criado, os valores dos campos sao imediatamente retornados a variavel 'height'.
		Assim que o objeto e criado para retornar um valor, como nos casos 'int', a referencia a esses objetos dentro da variavel 'height' e perdida, porque o programa nunca armazenou a referencia 
		em uma variavel de tipo equivalente. O objeto nao referenciado tem seus recursos liberados ao fim de sua execucao, e esses recursos sao reciclaveis pela JVM.
		
		No caso dos campos do tipo 'int', como eles nao sao estaticos, o compilador nao ira armazenar a informacao na memoria para uso em outras partes do codigo, fazendo com que a referencia ao 
		objeto morra e seja reciclada pela JVM, e toda vez fosse criado um novo objeto e chamado o valor da variavel de acordo com o uso das variaveis int. Caso fossem estaticas, teriamos uma
		referencia ativa na memoria. Qualquer valor retornado perduraria durante a execucao do programa para uso em outros locais do codigo.
		
		
	Inicializando um objeto:
	
		Aqui temos um exemplo da classe Point (por ser um exemplo pequeno, e viavel documenta-lo aqui):

		    public class Point {
		    	public int x = 0;
		    	public int y = 0;
		    	
		    	//constructor
		    	public Point(int a, int b) {
				x = a;
				y = b;
		    	}
		   }
		   
		A classe Point tem somente um construtor inteiro. Esse construtor recebe 2 argumentos inteiros (a, b), e atribui esses argumentos as variaveis x e y, respectivamente.
		Podemos chamar a classe Point com os seguintes dados:
		
		Point originOne = new Point(23, 94);
		
		O resultado do codigo acima tem uma ilustracao visual interessante, mas que nao consigo carregar a imagem aqui. Tentarei exemplificar de outra maneira:
		
			originOne	     Point Class
			    |			  |
			    |	  	  ------------------
			    |		  |		   |
			   ---		  |	x = 23;	   |
			   |o| ---------> |	y = 94;	   |
			   ---		  |		   |
					  ------------------
					  
		Na representacao acima, temos originOne, o objeto instanciado representado por um ponto dentro de uma caixinha. E, ao lado, uma caixa maior que simboliza a classe Point, do qual originOne
		e uma instancia, contendo os valores passados como argumento do construtor da classe.
		
		Temos tambem a classe Rectangle que contem 4 construtores. Obviamente, pelo tamanho do codigo fonte de exemplo, e inviavel documenta-lo aqui.
		Nessa classe, temos 3 variaveis: 2 inteiras (width e height) e uma de referencia do tipo Point (origin). todas elas sao public, nao oferencendo nenhum tipo de encapsulamento.
		
		Cada um dos 4 construtores da classe nos permite fornecer valores iniciais para origin, width e height, usando tipos primitivos e de referencia nos parametros.
		Como dito anteriormente em outro resumo, cada classe pode ter mais de um construtor, mas cada um deles deve ter uma assinatura diferente.
		Temos a chamada de um dos construtores e podemos atribuir isso a nosso exemplo do que foi dito na linha acima desta:
		
			Rectangle rectOne = new Rectangle(originOne, 100, 200);
			
		Quando o compilador encontra o codigo acima, ele entende que queremos chamar o construtor da classe que tem como parametro um objeto Point e dois tipos inteiros.
		Entao o compilador chama o construtor correspondente que inicializa origin com o argumento passado, no caso o objeto originOne, e define a largura e altura, respectivamente como 100 e 200.
		
		Agora existem duas referencias ao mesmo objeto Point: originOne e origin.
		Um objeto pode ter multiplas referencias a ele. Tentarei ilustrar, como na figura exemplo, a dupla referencia a um objeto:
			
			originOne	     Point Class	  _________________
			    |			  |		 |		   |
			    |	  	  ------------------	 |	-----------|------	
			    |		  |		   |	 |	|	   |	 |
			   ---		  |	x = 23;	   |------	|  	  ---	 |
			   |o| ---------> |	y = 94;	   |		|  origin |o|	 | <----- RectOne
			   ---		  |		   |		|	  ---	 |
					  ------------------		|  width = 100;	 |
					  				|  height = 200; |
					  				|		 |
					  				------------------
					  				
		Agora vamos inspecionar esse codigo: Rectangle rectTwo = new Rectangle(50, 100);
		
		O codigo acima cria um objeto retangulo chamado rectTwo, que recebe 2 argumentos inteiros. Se inspecionarmos o codigo do construtor, veremos que ele cria um objeto do tipo Point, cujo valores
		de x e y sao inicializados com 0.
		
		Agora vamos inspecionar esse codigo: Rectangle rect = new Rectangle();
		
		O codigo acima cria um objeto retangulo, usando um construtor que nao recebe argumentos.
		
		
	Consideracoes finais desse resumo:
		
		Recap de outro resumo:
			Todas as classes tem, ao menos, um construtor, como dito anteriormente.	Se a classe nao declarar nenhum explicitamente, o compilador o fara, declarando um construtor padrao. 
			Esse construtor	padrao chama o construtor de Object, se nao for uma classe filha (heranca). Se a classe tem uma classe pai (heranca) e essa subclasse nao tem um construtor, 
			o compilador vai checar se na classe pai tambem nao tem um construtor. Se nao, Object tem um, o compilador ira rejeitar o programa.
					  


Resumo sobre uso de objetos:

	Fazendo referencia aos campos de um objeto:
		
		Os campos de um objeto podem ser acessados pelo seu nome, isso dentro da classe de um objeto. Os nomes nao podem ser ambiguos.
		Poderiamos inserir uma instrucao dentro da classe Rectangle para imprimir os valores de width e height. width e height podem ser variaveis inteiras e isso pode ser facilmente chamado 
		dentro da classe Rectangle.
		
		Para chamarmos os valores acima fora da classe, usamos a referencia ou expressao do objeto, seguida pelo operador de ponto intermediario (.), seguido do nome do campo simples.
		Aqui esta a sintaxe: 
			objectReference.fieldName;
		
		Tentar imprimir tais valores sem a chamada do objeto antes do operador de ponto, apenas chamando o nome da variavel do objeto resulta em erro de compilacao, pois as variaveis que voce esta
		chamando existe apenas dentro do objeto.
		
		Independente de quantas instancias o mesmo construtor de uma classe tenha criado, cada uma delas terao valores exclusivos. Ou seja, cada objeto tera os mesmos elementos de uma classe 
		instanciada, mas com valores diferentes ou padronizados (dependendo do que se queira fazer).
		Se acessarmos os valores dos campos do objeto 1, depois do objeto 2, depois 3... veremos que eles terao valores personalizados, ou valores de inicializacao padrao, mas que podem ser alterados
		por metodos ou atribuicoes simples.
		A referencia de uso e acesso nao e da classe, mas sim do objeto em si. Mudar o valor de uma variavel de um objeto, nao impactara os valores daquela variavel em outros objetos.
		
		
	Chamando os metodos de um Objeto:
	
		Para chamar metodos de objetos, usamos a assinatura do metodo anexada a referencia do objeto, com um operador de ponto intermediario (.). Alem disso, se houver parametros configurados a esse
		metodo, deve-se fornecer argumentos. Caso contrario, os parenteses devem estar vazios.
		
		Para metodos que exibem valores ao usuario que estao dentro de um objeto, podemos chamar o objeto apontando a esse metodo em uma saida padrao (System.out), por exemplo.
		E para metodos que alteram valores, isso pode ser chamado em qualquer lugar do codigo (seria mais coerente que o metodo set nao fosse chamado numa saida padrao, pois nao ha o que mostrar ao
		usuario).
		
		E, ressaltando novamente, podemos utilizar uma variavel de referencia para armazenar um objeto ou um dado que ele retorna, mas tambem podemos utilizar uma expressao que retorne aquele objeto
		ou dado que ele retorna. O operador 'new' retorna uma referencia de um objeto para a variavel de referencia ou expressao que declaramos, para que possamos invocar metodos usando essa
		referencia que armazena o objeto retornado pelo operador 'new'. 
			Exemplo: 
				new Rectangle(100, 50).getArea();
				
		A expressao new Rectangle(100, 50) retorna uma referencia da classe Rectangle, com argumentos inicializados a esse objeto em 100 e 50. Em seguida, usando notacao de ponto, podemos 
		imediatamente obter a area desse objeto. Essa instancia de objeto com o retorno da area total pode ser armazenada em uma expressao de tipo primitivo equivalente ao que e retornado.
		getArea() retorna um int, entao podemos criar uma variavel int e atribuir o codigo acima a ela.
		Esse valor pode ser usado para tomar alguma decisao ou processar alguma outra parte do codigo que precise dela ou controlar um loop... isso vai variar de acordo com o que o planejamento 
		daquela variavel ira determinar.


		
Resumo sobre o coletor de lixo (Garbage Collector):

	Algumas linguagens de programacao obrigam que voce destrua um objeto criado na memoria para que os recursos possam ser reaproveitados, o que pode ser tedioso e altamente suscetivel a erros, alem de 
	tirar o enfoque do desenvolvimento de resolucao de problemas, desenvolvimento de novas funcionalidades e aprimoramentos das funcionalidades existentes em um projeto.
	Em Java, podemos criar quantos objetos quisermos (a unica limitacao seria o hardware e o OS). A JRE (Java Runtime Environment) tem a capacidade de destruir objetos quando determina que eles nao estao
	mais para ser utilizados, liberando recursos do sistema para que outros objetos possam performar, sem que isso se torne oneroso a maquina ou ao sistema. Isso se chama coleta de lixo 
	(ou garbage collector).
	
	Um objeto e elegivel para reciclagem quando nao existem mais referencias aquele objeto. As referencias mantidads em uma variavel geralmente sao destruidas quando a variavel sai do escopo de execucao.
	Ou podemos descartar um objeto atribuindo a ele o valor 'null'. Aqui devemos ter cautela, pois um objeto pode ter multiplas referencias a ele. Todas as referencias daquele objeto devem ser eliminadas
	antes que aquele objeto possa ser reciclado. Do contrario, podem ocorrer erros ao decorrer da execucao do projeto.
	
	A JRE possui um coletor de lixo que, periodicamente, realiza a eliminacao de objetos que nao estao mais sendo referenciados para liberar memoria.
	A JRE realiza essa funcao no momento certo, baseado em criterios internos da linguagem.
		
		

	
